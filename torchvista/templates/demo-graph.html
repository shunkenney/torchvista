<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <style>
            html, body {
                height: 100%;
                margin: 0;
                font-family: monospace;
            }

            .container {
                display: flex;
                flex-direction: column;
                height: 100vh;
            }

            .left-column {
                display: flex;
                flex-direction: row;
                max-height: 40vh;
            }

            .code-box {
                flex: 1.5;
                height: 100%;
                background-color: #f5f5f5;
                padding: 16px;
                overflow: auto;
                border-right: 1px solid #ccc;
                word-wrap: break-word;
                border-bottom: none;
            }

            .error-box {
                flex: 1;
                height: 100%;
                background-color: #f5f5f5;
                padding: 16px;
                overflow: auto;
                color: red;
                font-family: monospace;
                box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            }
            .code-box-header {
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #cccccc;
                color: #333;
                font-size: large;
            }

            .error-box-header {
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #000000;
                color: #333;
                font-size: large;
            }

            .graph-box-header {
                font-weight: bold;
                margin-bottom: 10px;
                padding-bottom: 5px;
                border-bottom: 1px solid #000000;
                color: #333;
                font-size: large;
            }

            /* Added for syntax highlighting */
            .code-box pre {
                margin: 0;
                padding: 0;
            }

            .code-box code {
                font-family: monospace;
            }

            .graph-view {
                height: 60vh;
                overflow: hidden;
                padding: 16px;
                background-color: #ffffff;
            }
            #graph {
                width: 100%;
                height: 100%;
            }
            .node rect {
                stroke: #333;
                fill: #fff;
            }
            text.node-label {
                font-family: "'Roboto', sans-serif";
                cursor: default;
                user-select: none;
            }
            text.type-indicator {
                font-family: "'Roboto', sans-serif";
                cursor: default;
                user-select: none;
            }
            text.collapse-icon {
                font-family: "'Roboto', sans-serif";
                font-size: 14px
                cursor: default;
                user-select: none;
            }
            .edge {
                stroke: #333333;
                fill: none;
            }
            .node rect.input { fill: #FF9AFF; }
            .node rect.constant { fill: rgb(235 235 235); }

            .node rect.output { fill: #FF9AFF; }
            .node rect.failed { fill: rgb(224 15 15); }
            .node rect.module { fill: #8BDEDB; }
            .node rect.operation { fill: #FEBC5A; }
            .edgeLabelGroup {
                pointer-events: none;
            }
            #arrowhead path {
                fill: #333333;;
            }
            .node rect,
            .node ellipse {
                transition: fill 0.3s ease;
            }

            .node .type-indicator {
                font-size: 5px;
                fill: rgba(0, 0, 0, 1.0);  /* Dark grey, semi-transparent */
                pointer-events: none;
            }

            .node.error rect {
                stroke: black;
                stroke-width: 1px;
                /* stroke-dasharray: 3, 3; */
                rx: 5px;
                ry: 5px;
            }

            .boundary-box.error > rect:first-of-type {
                fill: red;
                fill-opacity: 0.2;
            }

            #graph-container {
                position: relative;
            }
            .popup {
                position: absolute;
                background: white;
                border: 1px solid #ccc;
                width: 300px;
                max-height: 400px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                display: none;
                display: flex;
                flex-direction: column;
            }

            .popup-header {
                position: sticky;
                top: 0;
                background: white;
                padding: 5px 10px;
                border-bottom: 1px solid #ccc;
                display: flex;
                justify-content: space-between;
                align-items: center;
                z-index: 1;
            }

            .popup h3 {
                margin: 0;
                font-size: 16px;
            }

            .popup-content {
                padding: 10px;
                padding-bottom: 10px;
                overflow-y: auto;
                overflow-x: auto;
                flex-grow: 1;
            }

            .popup pre {
                white-space: pre;
                overflow-x: auto;
                font-family: monospace;
            }

            .popup-close {
                cursor: pointer;
                font-size: 24px;
                font-weight: bold;
                line-height: 1;
            }

            #popup-title {
                font-size: 24px;
            }

            #graph-container {
                position: relative;
            }

            pre {
                margin-bottom: 0;
            }

            .boundary-box rect {
                pointer-events: none;
            }
            .boundary-box text {
                pointer-events: none;
                user-select: none;
            }

            .boundary-box rect {
                pointer-events: none;
            }
            .boundary-box text {
                pointer-events: none;
                user-select: none;
                font-weight: bold;
            }
            .edge-label text {
                pointer-events: none;
                user-select: none;
                font-size: 4px;
                font-family: "'Roboto', sans-serif";
            }
            
            .collapse-button:hover {
                fill: #eee;
            }
            .collapse-icon {
                pointer-events: none;
                user-select: none;
                font-family: "'Roboto', sans-serif";
                fill: rgb(51, 51, 51);
            }

            /* Edge hover styles */
            .edge-group path {
              pointer-events: stroke;
            }

            .edge-label {
              pointer-events: all;
            }

            @keyframes containerHighlight {
              0% { 
                filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
              }
              25% { 
                filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
              }
              50% { 
                filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
              }
              75% { 
                filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
              }
              100% { 
                filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
              }
            }

            @keyframes containerStrokeHighlight {
              0% { 
                stroke-width: 1px;
              }
              25% { 
                stroke-width: 3px;
              }
              50% { 
                stroke-width: 1px;
              }
              75% { 
                stroke-width: 3px;
              }
              100% { 
                stroke-width: 1px;
              }
            }

            .highlight-cluster > rect:first-of-type {
              animation: 
                         containerStrokeHighlight 2.0s ease-in-out forwards;
            }

            .highlight-node rect {
              animation: 
                         containerStrokeHighlight 2.0s ease-in-out forwards;
            }

            text.node-label {
                font-family: "Roboto", sans-serif;
                font-size: 0.8rem;  /* Base size using rem units for accessibility */
                cursor: default;
                user-select: none;
            }

            .node.constant .node-label {
                font-size: 0.7rem;
            }

            .top-bar {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 12px 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                min-height: 25px;
            }

            .repo-title {
                font-size: 24px;
                font-weight: bold;
                margin: 0;
                font-family: 'Arial', sans-serif;
            }

            /* GitHub button iframe styling */
            .github-star-button {
                border-radius: 6px;
                overflow: hidden;
            }


        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
        <script src="https://unpkg.com/@viz-js/viz@3.12.0/lib/viz-standalone.js"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
        <script>
(function() {
    document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightBlock(block);
        });
    });


    const adj_list = ${adj_list_json};
    const module_info = ${module_info_json};
    const func_info_map = ${func_info_map_json};
    const module_name_to_base_name = ${module_name_to_base_name_json};
    const parent_module_to_nodes = ${parent_module_to_nodes_json};
    const parent_module_to_depth = ${parent_module_to_depth_json};
    const graph_node_name_to_without_suffix = ${graph_node_name_to_without_suffix};
    const ancestor_map = ${ancestor_map};
    const max_module_expansion_depth = ${max_module_expansion_depth};
    var collapsedContainers = new Set();
    const containerNodes = new Set();
    var adj_list_collapsed_nodes = {};
    let vizInstance = null;

    const EXPAND_TARGET_COVERAGE = 0.8;
    const COLLAPSE_TARGET_COVERAGE = 0.2;
    let lastModifiedContainer = null; // Track the last modified container
    let lastOperation = null; // Track whether it was 'expand' or 'collapse'
    
    function waitForLibs(callback) {
        if (typeof d3 !== 'undefined' && typeof Viz !== 'undefined') {
            Viz.instance().then(viz => {
                vizInstance = viz;
                callback();
            });
        } else {
            setTimeout(function() { waitForLibs(callback) }, 400);
        }
    }

    function extractGraphData(graphData) {
        const result = {
            nodes: {},
            edges: [],
            clusters: {}
        };

        // Process nodes - they have _gvid property and may have a "pos" attribute
        for (const obj of graphData.objects) {
            // Skip cluster objects (which are subgraphs)
            if (obj.name && obj.name.startsWith("cluster_")) {
                result.clusters[obj.name.replace("cluster_", "")] = {
                    bb: obj.bb, // Bounding box "x1,y1,x2,y2"
                    label: obj.label,
                    nodes: obj.nodes ? obj.nodes.map(id => graphData.objects[id].name) : []
                };
                continue;
            }
        
            // This is a node
            if (obj.pos) {
            const [x, y] = obj.pos.split(",").map(Number);
                result.nodes[obj.name] = {
                id: obj._gvid,
                name: obj.name,
                position: { x, y },
                    width: parseFloat(obj.width) * 72, // Convert to pixels (72 points per inch)
                    height: parseFloat(obj.height) * 72,
                    label: obj.label === "\\N" ? obj.name : obj.label
                };
            }
        }

        // Process edges
        for (const edge of graphData.edges) {
            const sourceId = edge.tail;
            const targetId = edge.head;
            
            // Find node names by their _gvid
            const sourceName = Object.values(result.nodes).find(n => n.id === sourceId)?.name;
            const targetName = Object.values(result.nodes).find(n => n.id === targetId)?.name;
            
            if (!sourceName || !targetName) continue;
            
                // Extract path points from the pos attribute
            let pathPoints = [];
            if (edge.pos) {
                // IMPORTANT CHANGE: Correctly handle the "e," prefix
                const posStr = edge.pos;
                // Check if the string starts with "e,"
                if (posStr.startsWith("e,")) {
                    // Split the string and extract coordinates correctly
                    const parts = posStr.split(" ");
                    // Extract the endpoint (first coordinate after "e,")
                    const endPoint = parts[0].substring(2).split(",").map(Number);
                    // Add the remaining points
                    pathPoints = parts.slice(1).map(point => {
                        const [x, y] = point.split(',').map(Number);
                        return { x, y };
                    });
                    
                    // Add the endpoint as the last point in the path
                    pathPoints.push({ x: endPoint[0], y: endPoint[1] });
                } else {
                    // Handle normal path without "e," prefix
                    pathPoints = posStr.split(' ').map(point => {
                    const [x, y] = point.split(',').map(Number);
                    return { x, y };
                    });
                }
            }
        
            result.edges.push({
                source: sourceName,
                target: targetName,
                path: pathPoints
            });
        }

        return result;
    }

    function identifyContainersWithFailedNodes(adj_list, ancestor_map) {
        const failedNodes = Object.keys(adj_list).filter(node => adj_list[node].failed);
      
        const containersWithFailedNodes = new Set();
      
        failedNodes.forEach(failedNode => {
            let currentNode = failedNode;

            while (ancestor_map[currentNode]) {
                const container = ancestor_map[currentNode];
                containersWithFailedNodes.add(container);
                currentNode = container;
            }
        });
      
        return containersWithFailedNodes;
    }


    function generateDotSource(adj_list, ancestor_map) {
        let dotSource = 'digraph G {\n';
        dotSource += '  rankdir=BT;\n'; // Top to bottom layout
        dotSource += '  node [shape=box];\n';

        // Clear and rebuild the containerNodes set
        containerNodes.clear();
        adj_list_collapsed_nodes = {};
        for (const value of Object.values(ancestor_map)) {
            if (value !== null && value !== undefined) {
                containerNodes.add(value);
            }
        }

        // Build container hierarchy
        const containerHierarchy = {};
        for (const [node, parent] of Object.entries(ancestor_map)) {
            if (parent && !containerHierarchy[parent]) {
                containerHierarchy[parent] = [];
            }
            if (parent) {
                containerHierarchy[parent].push(node);
            }
        }

        // Find top containers
        const topContainers = new Set();
        for (const container of containerNodes) {
            // A top container is one that doesn't have an ancestor itself
            if (!ancestor_map[container]) {
                topContainers.add(container);
            }
        }

        // Helper function to get all descendants of a container
        function getAllDescendants(container) {
            let descendants = [];
            const children = containerHierarchy[container] || [];

            for (const child of children) {
                descendants.push(child);
                if (containerNodes.has(child)) {
                    descendants = descendants.concat(getAllDescendants(child));
                }
            }

            return descendants;
        }

        let visibleCollapsedContainers = [];
        // Process containers
        function processContainer(containerName, level = 0) {
            const indent = ' '.repeat(level * 2);

            // Check if this container is collapsed
            if (collapsedContainers.has(containerName)) {
                // For collapsed containers, create a normal node instead of a subgraph
                visibleCollapsedContainers.push(containerName);
                dotSource += `${indent}"${containerName}";\n`;
                return;
            }

            // Start subgraph for non-collapsed containers
            dotSource += `${indent}subgraph cluster_${containerName} {\n`;
            dotSource += `${indent}  label="${containerName}";\n`;
            dotSource += `${indent}  style=rounded;\n`;

            // Get all direct children
            const children = containerHierarchy[containerName] || [];

            // Process child containers first
            for (const child of children) {
                if (containerNodes.has(child)) {
                    processContainer(child, level + 1);
                }
            }

            // Add regular nodes
            for (const child of children) {
                if (!containerNodes.has(child)) {
                    if (adj_list[child] && adj_list[child].node_type === "Constant") {
                        dotSource += `${indent}  "${child}" [width=0.7, height=0.3];\n`;
                    } else if (adj_list[child] && (adj_list[child].node_type === "Input" || adj_list[child].node_type === "Output")) {
                        dotSource += `${indent}  "${child}" [width=1.1, height=0.5];\n`;
                    } else {
                        dotSource += `${indent}  "${child}";\n`;
                    }
                }
            }

            // Close subgraph
            dotSource += `${indent}}\n`;
        }

        // Process all top containers
        for (const container of topContainers) {
            processContainer(container);
        }

        // Add standalone nodes (not in containers)
        for (const node of Object.keys(adj_list)) {
            if (!ancestor_map[node]) {
                if (adj_list[node] && adj_list[node].node_type === "Constant") {
                    dotSource += `  "${node}" [width=0.7, height=0.3];\n`;
                } else if (adj_list[node] && (adj_list[node].node_type === "Input" || adj_list[node].node_type === "Output")) {
                    dotSource += `  "${node}" [width=1.1, height=0.5];\n`;
                } else {
                    dotSource += `  "${node}";\n`;
                }
            }
        }

        // Process edges, handling collapsed containers
        for (const [node, data] of Object.entries(adj_list)) {
            for (const edge of data.edges) {
                let sourceNode = node;
                let targetNode = edge.target;
                let dims = edge.dims;
                let skipEdge = false;

                // Check if source node is inside a visible collapsed container
                for (const collapsedContainer of visibleCollapsedContainers) {
                    const descendants = getAllDescendants(collapsedContainer);

                    if (descendants.includes(node)) {
                        // Source node is inside a collapsed container, redirect edge from container
                        sourceNode = collapsedContainer;
                    }

                    if (descendants.includes(edge.target)) {
                        // Target node is inside a collapsed container, redirect edge to container
                        targetNode = collapsedContainer;
                    }

                    // Skip edges between nodes inside the same collapsed container
                    if (descendants.includes(node) && descendants.includes(edge.target)) {
                        skipEdge = true;
                    }
                }

                if (!skipEdge && sourceNode !== targetNode) {
                    dotSource += `  "${sourceNode}" -> "${targetNode}";\n`;
                      if (!(sourceNode in adj_list_collapsed_nodes)) {
                          adj_list_collapsed_nodes[sourceNode] = {'edges': []};
                      }
                      adj_list_collapsed_nodes[sourceNode]['edges'].push({'target': targetNode, 'dims': dims});
                }
            }
        }

        dotSource += '}';
        return dotSource;
    }

        
    function calculateBoundingBox(nodeGroup, nodePositions) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        nodeGroup.forEach(nodeName => {
            const node = nodePositions[nodeName];
            if (node) {
                minX = Math.min(minX, node.x - node.width / 2);
                minY = Math.min(minY, node.y - node.height / 2);
                maxX = Math.max(maxX, node.x + node.width / 2);
                maxY = Math.max(maxY, node.y + node.height / 2);
            }
        });
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }

    function reloadGraph() {
        d3.select("#graph_${unique_id}").html("");
        const dotSource = generateDotSource(adj_list, ancestor_map);

        graphData = vizInstance.renderJSON(dotSource)
        // Extract the graph data with positions from Graphviz
        const extractedGraphData = extractGraphData(graphData);

        
        // Now create the graph with the Graphviz layout data
        createGraph(extractedGraphData);

        // renderGraphvizImage(dotSource);
    }
                
    function initializeCollapsedContainersFromGraph() {
        const containerDepths = new Map();
        
        function getContainerDepth(container) {
            if (containerDepths.has(container)) {
                return containerDepths.get(container);
            }
            
            let depth = 0;
            for (const [child, parent] of Object.entries(ancestor_map)) {
                if (child === container && parent) {
                    depth = getContainerDepth(parent) + 1;
                    break;
                }
            }
            
            containerDepths.set(container, depth);
            return depth;
        }
        
        for (const container of containerNodes) {
            const depth = getContainerDepth(container);
            if (depth >= max_module_expansion_depth) {
                collapsedContainers.add(container);
            }
        }
    }

    waitForLibs(function() {
        reloadGraph();
        
        initializeCollapsedContainersFromGraph();
        
        if (collapsedContainers.size > 0) {
            reloadGraph();
        }
    });

    function findErrorNode(nodes) {
        return nodes.find(node => adj_list[node].failed);
    }



    // Add this function to render the raw Graphviz visualization
    function renderGraphvizImage(dotSource) {
        // Create a container for the Graphviz image
        const graphvizContainer = d3.select("#graph-container_${unique_id}")
            .append("div")
            .attr("id", "graphviz-image-container")
            .style("margin-top", "20px")
            .style("border-top", "1px solid #ccc")
            .style("padding-top", "20px");
      
        graphvizContainer.append("h3")
            .text("Original Graphviz Rendering")
            .style("text-align", "center");
        
        // Use Viz.js to render the DOT source directly to SVG
        svgElement = vizInstance.renderSVGElement(dotSource)
        // Append the SVG element to the container
        graphvizContainer.node().appendChild(svgElement);
          
        // Style the SVG
        d3.select(svgElement)
            .attr("width", "100%")
            .attr("height", "600px")
            .style("background-color", "#f9f9f9");
        
    }

    function createGraph(graphvizData) {
        const svg = d3.select("#graph_${unique_id}")
        .append("svg")
        .attr("width", "100%")
        .attr("height", "100%")
        .style("background-color", "#f3f3eb");

        const inner = svg.append("g");

        // Add zoom behavior
        const zoom = d3.zoom().on("zoom", function(event) {
            inner.attr("transform", event.transform);
            closePopup();
        });

        svg.call(zoom);

        // Define arrowhead marker
        svg.append("defs").append("marker")
        .attr("id", "arrowhead_${unique_id}")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 8)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#333");

        // Draw clusters (container boxes) first so they're behind nodes
        const clusters = inner.selectAll(".boundary-box")
        .data(Object.entries(graphvizData.clusters))
        .enter()
        .append("g")
        .attr("class", "boundary-box");

        const containersWithFailedNodes = identifyContainersWithFailedNodes(adj_list, ancestor_map);

        clusters.each(function([clusterName, clusterData]) {
            const group = d3.select(this);

            

            const hasFailedNodes = containersWithFailedNodes.has(clusterName);
            if (hasFailedNodes) {
                group.classed("error", true);
            }

            // Parse bounding box coordinates
            const [x1, y1, x2, y2] = clusterData.bb.split(",").map(Number);
            
            // Create boundary box
            group.append("rect")
            .attr("x", x1)
            .attr("y", y1)
            .attr("width", x2 - x1)
            .attr("height", y2 - y1)
            .attr("fill-opacity", 0.0)
            .attr("stroke", "black")
            .attr("stroke-width", 1)
            .attr("rx", 5)
            .attr("ry", 5);
                
            // Create label for the cluster
            const textGroup = group.append("g")
            .attr("transform", `translate(${x1 + 10}, ${y1 + 3})`);
            
            const text = textGroup.append("text")
            .text(clusterData.label)
            .attr("text-anchor", "start")
            .attr("dominant-baseline", "hanging")
            .attr("dy", "-6")
            .attr("font-size", 7)
            .attr("fill", "#333")
            .attr("stroke", "#f3f3eb")
            .attr("stroke-width", "5px")
            .attr("paint-order", "stroke")
            .attr("stroke-linejoin", "round");
                        
            
            // Add collapse/expand button
            group.append("circle")
            .attr("class", "collapse-button")
            .attr("cx", x1 + 10)
            .attr("cy", y1 + 10)
            .attr("r", 6)
            .attr("fill", "#fff")
            .attr("stroke", "#333")
            .attr("stroke-width", 1)
            .attr("cursor", "pointer");
            
            // Add "-" symbol
            group.append("text")
            .attr("class", "collapse-icon")
            .attr("x", x1 + 10)
            .attr("y", y1 + 10)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("cursor", "pointer")
            .text("—");
        });

        // Add click event handler for collapse buttons
        clusters.selectAll(".collapse-button, .collapse-icon")
        .on("click", function(event, [clusterName, clusterData]) {
            event.stopPropagation(); // Prevent event from bubbling to SVG
            // Collapse the container
            collapsedContainers.add(clusterName);
            
            // Track this container and operation for centering after reload
            lastModifiedContainer = clusterName;
            lastOperation = "collapse";
            reloadGraph();
        });

        
        // Create edges using the path points from Graphviz
        const edges = inner.selectAll(".edge")
        .data(graphvizData.edges)
        .enter()
        .append("g")
        .attr("class", "edge-group");
        
        // Add the actual path
        edges.append("path")
        .attr("class", "edge")
        .attr("d", function(edge) {
            if (edge.path && edge.path.length > 0) {
                    // Create a proper SVG path using Bézier curves
                let d = "";
                const points = edge.path;
                
                    // Start at the first point
                d += `M${points[0].x},${points[0].y}`;
                
                    // Create cubic Bézier curves
                for (let i = 1; i < points.length - 2; i += 3) {
                    if (i + 2 < points.length) {
                        d += ` C${points[i].x},${points[i].y} ${points[i+1].x},${points[i+1].y} ${points[i+2].x},${points[i+2].y}`;
                    }
                }
                
                    // If we have leftover points, draw a line to the last point
                if (points.length % 3 !== 1) {
                    d += ` L${points[points.length-1].x},${points[points.length-1].y}`;
                }
                
                return d;
            }
            return "";
        })
        .attr("marker-end", "url(#arrowhead_${unique_id})");
        
        // Add dimension labels on edges
        edges.each(function(edge) {
            const edgeGroup = d3.select(this);
            const path = edgeGroup.select("path").node();
            
            if (!path) return;
            
            // Find the source node data
            if (!adj_list[edge.source] && !adj_list_collapsed_nodes[edge.source]) return;
            
            // Find the edge data with matching target
            let sourceNodeData = adj_list_collapsed_nodes[edge.source];
            if (!sourceNodeData) {
                sourceNodeData = adj_list[edge.source];
            }
            const edgeData = sourceNodeData.edges.find(e => e.target === edge.target);
            if (!edgeData || !edgeData.dims) return;
            
            // Calculate position for label - near the start of the edge
            // Get a point that's 20% along the path
            const pathLength = path.getTotalLength();
            const pointAtStart = path.getPointAtLength(pathLength * 0.5);
            
            // Get path direction at that point for text rotation
            const pointBefore = path.getPointAtLength(pathLength * 0.4);
            const pointAfter = path.getPointAtLength(pathLength * 0.6);
            // const angle = Math.atan2(pointAfter.y - pointBefore.y, pointAfter.x - pointBefore.x) * 180 / Math.PI;
            const angle = 0.0;
            
            // Create a background for the text
            const labelGroup = edgeGroup.append("g")
            .attr("class", "edge-label")
            .attr("transform", `translate(${pointAtStart.x}, ${pointAtStart.y})`);
            
            const text = labelGroup.append("text")
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "central")
            .style("font-size", "5px")
            .text(edgeData.dims)
            .attr("transform", `rotate(${angle})`)
            .attr("stroke", "#f3f3eb")
            .attr("stroke-width", "5px")
            .attr("paint-order", "stroke")
            .attr("stroke-linejoin", "round");

            // Add background rectangle
            const bbox = text.node().getBBox();
            labelGroup.insert("rect", "text")
            .attr("x", bbox.x - 2)
            .attr("y", bbox.y - 2)
            .attr("rx", 4)
            .attr("ry", 4)
            .attr("width", bbox.width + 4)
            .attr("height", bbox.height + 4)
            .attr("fill", "rgb(243, 243, 235) ")
            .attr("fill-opacity", 1.0)
            .attr("transform", `rotate(${angle})`);
        });
        

        // Add hover effects to edge paths
        edges.each(function() {
            const edgeGroup = d3.select(this);
            const path = edgeGroup.select("path");
            const labelGroup = edgeGroup.select(".edge-label");
            const labelText = labelGroup.select("text");
            const labelBg = labelGroup.select("rect");
            const originalStrokeWidth = path.attr("stroke-width") || 1;
            const originalFontSize = labelText.style("font-size") || "5px";
            const originalParent = edgeGroup.node().parentNode;
            const originalPosition = Array.from(originalParent.childNodes).indexOf(edgeGroup.node());
            
            function highlightEdge() {
                // Move to end of parent's children list to appear on top
                originalParent.appendChild(edgeGroup.node());
                
                // Make edge thicker
                path.attr("stroke-width", parseFloat(originalStrokeWidth) * 1.4);
                
                // Make label text larger
                labelText.style("font-size", "7px");
                    
                // Adjust the background rectangle for the label
                const bbox = labelText.node().getBBox();
                labelBg.attr("x", bbox.x - 2)
                    .attr("y", bbox.y - 2)
                    .attr("width", bbox.width + 4)
                    .attr("height", bbox.height + 4);
            }
            
            function resetEdge() {
                // Restore original position in parent's children list
                const currentIndex = Array.from(originalParent.childNodes).indexOf(edgeGroup.node());
                if (currentIndex !== originalPosition) {
                    // Insert back at original position
                    const referenceNode = originalParent.childNodes[originalPosition] || null;
                    originalParent.insertBefore(edgeGroup.node(), referenceNode);
                }
                
                // Restore original edge thickness
                path.attr("stroke-width", originalStrokeWidth);
                
                // Restore original label text size
                labelText.style("font-size", originalFontSize);
                    
                // Restore original background rectangle size
                const bbox = labelText.node().getBBox();
                labelBg.attr("x", bbox.x - 2)
                    .attr("y", bbox.y - 2)
                    .attr("width", bbox.width + 4)
                    .attr("height", bbox.height + 4);
            }
            
            // Add hover events to the path
            path.on("mouseenter", highlightEdge)
                .on("mouseleave", resetEdge);
            
            // Add hover events to label group (both text and background)
            if (labelGroup.node()) {
                labelText.on("mouseenter", highlightEdge)
                    .on("mouseleave", resetEdge);
                    
                labelBg.on("mouseenter", highlightEdge)
                    .on("mouseleave", resetEdge);
            }
        });


        // Create nodes using positions from Graphviz
        const nodes = inner.selectAll(".node")
            .data(Object.entries(graphvizData.nodes))
            .enter()
            .append("g")
            // In the createGraph function, when you're creating nodes, modify the class assignment:
            .attr("class", function([nodeName, nodeData]) {
                let classes = "node";
                if ((adj_list[nodeName] && adj_list[nodeName].failed) || containersWithFailedNodes.has(nodeName)) classes += " error";
                if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Input")) classes += " input";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Module") || (collapsedContainers.has(nodeName))) classes += " module";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Output")) classes += " output";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Operation")) classes += " operation";
                else if ((adj_list[nodeName] && adj_list[nodeName].node_type === "Constant")) classes += " constant";
                return classes;
            })
            .attr("transform", function([nodeName, nodeData]) {
                return `translate(${nodeData.position.x}, ${nodeData.position.y})`;
            });
        
        // Filter nodes for click event - don't include input or output nodes
        inner.selectAll(".node")
            .filter(function([nodeName]) {
                return !(((adj_list[nodeName] && adj_list[nodeName].node_type === "Output")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Input")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Constant"))) && !collapsedContainers.has(nodeName)
            })
            .on("click", showPopup);

        
        // Add rectangles for nodes
        nodes.append("rect")
        .attr("width", function([nodeName, nodeData]) { return nodeData.width; })
        .attr("height", function([nodeName, nodeData]) { return nodeData.height; })
        .attr("x", function([nodeName, nodeData]) { return -nodeData.width / 2; })
        .attr("y", function([nodeName, nodeData]) { return -nodeData.height / 2; })
        .attr("class", function([nodeName]) { 
            if (adj_list[nodeName] && adj_list[nodeName].node_type === "Input") return "input";
            if (adj_list[nodeName] && adj_list[nodeName].node_type === "Output") return "output";
            if (adj_list[nodeName] && adj_list[nodeName].node_type === "Constant") return "constant";
            if ((adj_list[nodeName] && adj_list[nodeName].failed) || containersWithFailedNodes.has(nodeName)) return "failed";
            return ((adj_list[nodeName] && adj_list[nodeName].node_type === "Module") || (collapsedContainers.has(nodeName))) ? "module" : "operation";
        });
        
        // Add labels for nodes
        nodes.append("text")
        .attr("class", "node-label")
        .text(function([nodeName]) { return graph_node_name_to_without_suffix[nodeName] || nodeName; })
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central");
        
        // Add type indicators
        nodes.filter(function([nodeName]) {
            return !(((adj_list[nodeName] && adj_list[nodeName].node_type === "Output")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Input")) || ((adj_list[nodeName] && adj_list[nodeName].node_type === "Constant")));
        }).append("text")
        .attr("class", "type-indicator")
        .attr("text-anchor", "end")
        .attr("dominant-baseline", "hanging")
        .attr("transform", function([nodeName, nodeData]) {
            return `translate(${nodeData.width / 2 - 3}, ${-nodeData.height / 2 + 3})`;
        })
        .text(function([nodeName]) {
            return (adj_list[nodeName] && adj_list[nodeName].node_type === "Module") || (collapsedContainers.has(nodeName)) ? "Module" : "Tensor Op";
        });

        // Add collapse/expand buttons to collapsed container nodes
        inner.selectAll(".node")
        .filter(function([nodeName]) {
            return collapsedContainers.has(nodeName);
        })
        .each(function([nodeName, nodeData]) {
            const nodeGroup = d3.select(this);
            const width = nodeData.width;
            const height = nodeData.height;        
            // Add collapse/expand button (with "+" since it's collapsed)
            nodeGroup.append("circle")
            .attr("class", "collapse-button")
            .attr("cx", -width/2 + 8)
            .attr("cy", -height/2 + 8)
            .attr("r", 6)
            .attr("fill", "#fff")
            .attr("stroke", "#333")
            .attr("stroke-width", 1)
            .attr("cursor", "pointer");
        
            // Add "+" symbol
            nodeGroup.append("text")
            .attr("class", "collapse-icon")
            .attr("x", -width/2 + 8)
            .attr("y", -height/2 + 8) 
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("cursor", "pointer")
            .text("+");
            
            // Add click handler using the existing reloadGraph function
            nodeGroup.selectAll(".collapse-button, .collapse-icon")
            .on("click", function(event) {
                event.stopPropagation();
                
                // Always expanding when clicked (since these are collapsed containers)
                collapsedContainers.delete(nodeName);

                // Track this container and operation for centering after reload
                lastModifiedContainer = nodeName;
                lastOperation = "expand";
                
                // Use the existing reloadGraph function
                reloadGraph();
            });
        });    

        // Add hover effects
        nodes.each(function() {
            const nodeGroup = d3.select(this);
            const rect = nodeGroup.select("rect");
            const originalColor = rect.style("fill");
            let isHovered = false;
            
            nodeGroup.on("mouseenter", function() {
                if (!isHovered) {
                    isHovered = true;
                    const currentColor = d3.color(rect.style("fill") || originalColor);
                    rect.style("fill", currentColor.brighter(0.4));
                }
            })
            .on("mouseleave", function() {
                isHovered = false;
                rect.style("fill", originalColor);
            });
        });
        
        
        // Implement popup functionality
        function showPopup(event, [nodeName]) {
            event.stopPropagation();
            
            const popup = d3.select("#popup_${unique_id}");
            const clickedElement = d3.select(this).select("rect").node();
            const moduleTemplate = d3.select("#module-template_${unique_id}");
            const tensorOpTemplate = d3.select("#tensor-op-template_${unique_id}");
            const noInfoMessage = d3.select("#no-info_${unique_id}");
            
            const nodeData = adj_list[nodeName];
            
            d3.select("#popup-title_${unique_id}").text(graph_node_name_to_without_suffix[nodeName] || nodeName);
            
            // d3.select("#input-dims_${unique_id}").text(nodeData.input_dims);
            // d3.select("#output-dims_${unique_id}").text(nodeData.output_dims);
            
            moduleTemplate.style("display", "none");
            tensorOpTemplate.style("display", "none");
            noInfoMessage.style("display", "none");
            
            if (((adj_list[nodeName] && adj_list[nodeName].node_type === "Module")) && (module_info[nodeName] || (module_name_to_base_name[nodeName] && module_info[module_name_to_base_name[nodeName]]))) {
                const info = module_info[nodeName] ? module_info[nodeName] : module_info[module_name_to_base_name[nodeName]];
                moduleTemplate.style("display", "block").classed("content-shown", true);
                
                d3.select("#module-type_${unique_id}").text(info.type || 'N/A');
                d3.select("#module-attributes_${unique_id}").text(JSON.stringify(info.attributes, null, 2));
                d3.select("#module-parameters_${unique_id}").text(JSON.stringify(info.parameters, null, 2));
                d3.select("#module-extra-repr_${unique_id}").text(info.extra_repr || 'N/A');
            } else if (!(adj_list[nodeName] && adj_list[nodeName].node_type === "Input") && func_info_map[nodeName]) {
                const info = func_info_map[nodeName];
                tensorOpTemplate.style("display", "block").classed("content-shown", true);
                
                d3.select("#tensor-parameters_${unique_id}").text(JSON.stringify(info, null, 2));
            } else {
                noInfoMessage.style("display", "block").classed("content-shown", true);
            }
            
            const boundingBox = clickedElement.getBoundingClientRect();
            const containerRect = d3.select("#graph-container_${unique_id}").node().getBoundingClientRect();
            
            const x = boundingBox.left + boundingBox.width / 2 - containerRect.left;
            const y = boundingBox.top + boundingBox.height / 2 - containerRect.top;
            
            popup.style("left", `${x}px`)
            .style("top", `${y}px`)
            .style("display", "flex");
            d3.select("#popup-content_${unique_id}").node().scrollTop = 0;
        }
        
        function closePopup() {
            d3.select("#popup_${unique_id}").style("display", "none");
        }
        
        d3.select(".popup-close").on("click", closePopup);
        svg.on("click", closePopup);
        
        // Calculate view box to ensure the graph is properly scaled and centered
        const findErrorNode = (nodes) => {
            for (const [nodeName] of nodes) {
                if (adj_list[nodeName] && adj_list[nodeName].failed) {
                    return nodeName;
                }
            }
            return null;
        };
        
        const errorNode = findErrorNode(Object.entries(graphvizData.nodes));
        
        // Initial zoom setup
        const svgNode = svg.node();
        const width = svgNode.clientWidth || 800; // Fallback if clientWidth is 0
        const height = svgNode.clientHeight || 600; // Fallback if clientHeight is 0
        
        if (lastModifiedContainer && (Object.keys(graphvizData.nodes).includes(lastModifiedContainer) || 
            Object.keys(graphvizData.clusters).includes(lastModifiedContainer))) {
            
            // Center on the container that was just expanded or collapsed
            let targetCoverage = lastOperation === "expand" ? EXPAND_TARGET_COVERAGE : COLLAPSE_TARGET_COVERAGE;
            let targetNode;
            let targetPos;
            let containerWidth, containerHeight;
            
            if (Object.keys(graphvizData.nodes).includes(lastModifiedContainer)) {
                // It's a node (collapsed container)
                targetNode = graphvizData.nodes[lastModifiedContainer];
                targetPos = { x: targetNode.position.x, y: targetNode.position.y };
                containerWidth = targetNode.width;
                containerHeight = targetNode.height;
            } else if (Object.keys(graphvizData.clusters).includes(lastModifiedContainer)) {
                // It's a cluster (expanded container)
                const clusterData = graphvizData.clusters[lastModifiedContainer];
                const [x1, y1, x2, y2] = clusterData.bb.split(",").map(Number);
                targetPos = { x: (x1 + x2) / 2, y: (y1 + y2) / 2 };
                containerWidth = x2 - x1;
                containerHeight = y2 - y1;
            }
            
            if (targetPos && containerWidth && containerHeight) {
                // Calculate scale to make container occupy the target percentage of viewport
                const widthScale = (width * targetCoverage) / containerWidth;
                const heightScale = (height * targetCoverage) / containerHeight;
                // Use the smaller scale to ensure container fits in viewport
                const targetScale = Math.min(widthScale, heightScale);
                
                const translate = [
                    width / 2 - targetPos.x * targetScale,
                    height / 2 - targetPos.y * targetScale
                ];
                
                svg.call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(targetScale));
                
                // Apply highlight effect to the target container
                if (Object.keys(graphvizData.nodes).includes(lastModifiedContainer)) {
                    // Highlight the node (collapsed container)
                    const targetElement = inner.selectAll(".node")
                        .filter(([nodeName]) => nodeName === lastModifiedContainer);
                        
                    if (!targetElement.empty()) {
                        targetElement.classed("highlight-node", true);
                        
                        // Remove the highlight class after animation completes
                        setTimeout(() => {
                            targetElement.classed("highlight-node", false);
                        }, 2000); // Match the animation duration
                    }
                } else if (Object.keys(graphvizData.clusters).includes(lastModifiedContainer)) {
                    // Highlight the cluster (expanded container)
                    const targetElement = inner.selectAll(".boundary-box")
                        .filter(function([clusterName]) {
                            return clusterName === lastModifiedContainer;
                        });
                        
                    if (!targetElement.empty()) {
                        targetElement.classed("highlight-cluster", true);
                        
                        // Remove the highlight class after animation completes
                        setTimeout(() => {
                            targetElement.classed("highlight-cluster", false);
                        }, 2000); // Match the animation duration
                    }
                }
                
                // Reset tracking variables after applying the transformation
                lastModifiedContainer = null;
                lastOperation = null;
            }
        } else if (errorNode) {
            // Focus on the error node if there is one
            const nodeData = graphvizData.nodes[errorNode];
            if (nodeData) {
                const scale = 2; // Zoom in on error node
                const translate = [
                    width / 2 - nodeData.position.x * scale,
                    height / 2 - nodeData.position.y * scale
                    ];
                
                svg.call(zoom.transform, d3.zoomIdentity
                    .translate(translate[0], translate[1])
                    .scale(scale));
            }
        } else {
            // Show the entire graph
            // Find the bounds of the graph
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            Object.values(graphvizData.nodes).forEach(node => {
                minX = Math.min(minX, node.position.x - node.width / 2);
                minY = Math.min(minY, node.position.y - node.height / 2);
                maxX = Math.max(maxX, node.position.x + node.width / 2);
                maxY = Math.max(maxY, node.position.y + node.height / 2);
            });
            
            // Also consider cluster bounding boxes
            Object.values(graphvizData.clusters).forEach(cluster => {
                const [x1, y1, x2, y2] = cluster.bb.split(",").map(Number);
                minX = Math.min(minX, x1);
                minY = Math.min(minY, y1);
                maxX = Math.max(maxX, x2);
                maxY = Math.max(maxY, y2);
            });
            
            const graphWidth = maxX - minX;
            const graphHeight = maxY - minY;
            
            // Determine scale to fit the entire graph with some padding
            const scale = Math.min(width / graphWidth, height / graphHeight) * 0.9;
            
            // Center the graph
            const translate = [
                width / 2 - (minX + graphWidth / 2) * scale,
                height / 2 - (minY + graphHeight / 2) * scale
                ];
            
            svg.call(zoom.transform, d3.zoomIdentity
                .translate(translate[0], translate[1])
                .scale(scale));
        }
            
    }
})();
        </script>

        <div class="container">
            <div class="top-bar">
                <h1 class="repo-title">TorchVista</h1>
                <!-- GitHub's official star button -->
                <iframe src="https://ghbtns.com/github-btn.html?user=sachinhosmani&repo=torchvista&type=star&count=true&size=large" 
                        frameborder="0" scrolling="0" width="170" height="30" title="GitHub Star Button"></iframe>
            </div>
            <div class="left-column">

<div class="code-box" id="codeBox">
    <div class="code-box-header">Sample code (Not editable)</div>
    <pre><code class="language-python">${code_contents}</code></pre>
</div>

<div class="error-box" id="errorBox">
    <div class="error-box-header">Error Output (if any)</div>
${error_contents}
</div>

            </div>
    
            <div class="graph-view" id="graphContainer" style="height: 100%">
                <div class="graph-box-header">Visualized Interactive Graph</div>
                <div id="graph-container_${unique_id}" style="height: 97%; overflow: auto; position: relative;">
                    <div id="graph_${unique_id}" style="height: 100%"></div>
                    <div id="popup_${unique_id}" class="popup" style="display: none;">
                        <div class="popup-header">
                            <h3 id="popup-title_${unique_id}"></h3>
                            <span class="popup-close">✕</span>
                        </div>
                        <div id="popup-content_${unique_id}" class="popup-content">
                            <div id="common-info_${unique_id}">
                            </div>
                            <div id="module-template_${unique_id}" style="display:none;">
                                <p><strong>Type:</strong> <span id="module-type_${unique_id}"></span></p>
                                <p><strong>Attributes:</strong></p>
                                <pre id="module-attributes_${unique_id}"></pre>
                                <p><strong>Parameters:</strong></p>
                                <pre id="module-parameters_${unique_id}"></pre>
                                <p><strong>Extra Repr:</strong></p>
                                <pre id="module-extra-repr_${unique_id}"></pre>
                            </div>
                            <div id="tensor-op-template_${unique_id}" style="display:none;">
                                <p><strong>Parameters:</strong></p>
                                <pre id="tensor-parameters_${unique_id}"></pre>
                            </div>
                            <p id="no-info_${unique_id}" style="display:none;">No further information available for this node.</p>
                        </div>
                    </div>
                    <div id="popup-content_${unique_id}"></div>
                </div>
            </div>
        </div>
    </body>
</html>
